<nav class="section-menu">
    <div class="centering layout">
        <input type="search" placeholder="Suchen..." class="search-input" id="search-input" />
    </div>
    <ul class="section-menu-list">
        {{ template "menu" (dict "page" .FirstSection "currentPage" .) }}
    </ul>
</nav>

{{ define "menu" }}
    {{ $currPage := .currentPage }}
    {{ range .page.Pages }}
        <li class="{{ if eq . $currPage }}active{{ end }}">
            <a href="{{ .RelPermalink }}">
                <i class="icon fal fa-{{ (default "scroll" (default .Parent.Params.icon .Params.icon)) }}"></i>
                <span class="title">
                    {{ .Title }}
                </span>
            </a>

            {{ $hiddenAttr := "" }}

            {{ if not (or (.IsAncestor $currPage) (eq .Permalink $currPage.Permalink)) }}
                {{ $hiddenAttr = "hidden" }}
            {{ end }}

            {{ if .IsNode }}
                <ul {{ $hiddenAttr }}>
                    {{ template "menu" (dict "page" . "currentPage" $currPage) }}
                </ul>
                {{ else }}
                <ul class="table-of-contents" {{ $hiddenAttr }}>
                    {{ .TableOfContents | replaceRE "<nav[^<]*>(\\s*<ul>\\s*([\\w\\W]*)</ul>\\s*)?</nav>" "$2" | replaceRE "href=\"(.*)\"" (printf "href=\"%s$1\"" .RelPermalink ) | safeHTML }}
                </ul>
            {{ end }}
        </li>
    {{ end }}
{{ end }}

<script>
    window.addEventListener("load", () => {
        const currentItems = [...document.querySelectorAll(".table-of-contents:not([hidden]) li")];
        const headings = document.querySelectorAll("h2[id], h3[id]");
        const container = document.querySelector(".section-menu");
        const allItems = [...document.querySelectorAll(".section-menu li")];
        const input = document.querySelector(".section-menu input");
        input.focus();
        document.documentElement.style.scrollBehavior = "smooth";

        let timeout;
        function scrollTo(el) {
            clearTimeout(timeout);
            timeout = setTimeout(() => {
                try {
                    el.scrollIntoViewIfNeeded();
                } catch (e) {
                    el.scrollIntoView();
                }
            }, 500);
        }

        const observer = new IntersectionObserver(
            (entries) => {
                for (const entry of entries) {
                    const id = entry.target.id;
                    const items = currentItems.filter((item) => {
                        const link = item.querySelector("a");
                        return link && link.getAttribute("href").endsWith(`#${id}`);
                    });
                    items.forEach((item) => (item.dataset.headerVisible = entry.isIntersecting));
                }

                const firstVisibleIndex = currentItems.findIndex((item) => item.dataset.headerVisible === "true");
                const firstVisible =
                    currentItems[firstVisibleIndex - 1] || (firstVisibleIndex && currentItems[firstVisibleIndex]);
                if (firstVisible) {
                    currentItems.forEach((item) => item.classList.remove("active"));
                    firstVisible.classList.add("active");
                    currentItems
                        .filter((item) => !!item.querySelector("li.active"))
                        .forEach((item) => item.classList.add("active"));
                    scrollTo(firstVisible);
                }
            },
            { root: document, rootMargin: "-100px 0px 200px 0px", threshold: 1 }
        );

        headings.forEach((heading) => observer.observe(heading));

        input.addEventListener("input", () => {
            const vals = input.value.split(" ").filter((val) => !!val);
            container.classList.toggle("searching", !!vals.length);

            if (vals.length) {
                allItems.forEach((item) => {
                    const titleEl = item.querySelector("a .title") || item.querySelector("a");
                    titleEl && (titleEl.innerHTML = titleEl.innerHTML.replace(/<\/?mark>/g, ""));
                    const innerMatch = vals.some((val) => item.textContent.toLowerCase().includes(val.toLowerCase()));
                    if (innerMatch) {
                        titleEl &&
                            (titleEl.innerHTML = titleEl.innerHTML.replaceAll(
                                new RegExp(vals.join("|"), "gi"),
                                "<mark>$&</mark>"
                            ));
                        item.removeAttribute("hidden");
                    } else {
                        item.setAttribute("hidden", "");
                    }
                });
            } else {
                allItems.forEach((item) => {
                    const titleEl = item.querySelector("a .body") || item.querySelector("a");
                    titleEl && (titleEl.innerHTML = titleEl.innerHTML.replace(/<\/?mark>/g, ""));
                    item.removeAttribute("hidden");
                });
            }
        });
    });
</script>
